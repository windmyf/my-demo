#### runnable和Callable有什么区别
相同点：
    1) 都是接口
    2) 都可以编写多线程程序
    3) 都采用Thread.start()启动线程
    
主要区别：
    1) Runnable接口run()方法无返回值；Callable接口call()方法有返回值，
        是个泛型，和Future、FutureTask配合可以用来获取异步执行结果;
    2) Runnable接口run()方法只能抛出运行时异常，且无法捕获处理；Callable接口
        call方法允许抛出异常，可以获取异常信息。

* 注：Callable接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞
        主进程的继续往下执行，如果不调用不会阻塞。
  

#### 线程的run()方法与start()有什么区别

        每个线程都是通过某个特定的Thread对象所对应的方法run()来完成操作的，run()方法称为线程体。
    通过调用Thread类的start()方法来启动一个线程
    
        start()方法用于启动线程，run()方法用于执行线程运行时代码。
    run()方法可以重复调用，而start()只能调用一次。
    
        start()方法用来启动一个线程，真正实现了多线程运行。调用start()方法无需等待run()方法体代码执行完毕，
    直接可以继续执行其他代码；此时线程是处于就绪状态，并没有运行。然后通过此Thread类调用方法run()来完成
    其运行状态，run()方法运行结束，此线程终止。然后CPU在调用其他线程。
    
        run()方法是在本线程里的，只是线程里的一个函数，而不是多线程。如果直接调用run(),其实就相当于调用了
    一个普通的函数而已，直接调用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有
    一条，根本没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。
    
#### 什么是Callable和Future
        Callable接口类似于Runnable,从名字就可以看出来，但是Runable不会返回结果，并且无法抛出返回结果的异常，
    而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到
    异步执行任务的返回值；
    
        Future接口表示异步任务，是一个可能还没有完成的异步任务的结果。所以说Callable用于产生结果，Future用于获取结果；
        
### 线程的状态和基本操作
#### 线程的生命周期及五种基本状态
![线程的基本状态](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy8xMi8xNS8xNjA1OWNjOTFlZThlZmIz?x-oss-process=image/format,png)
  1) 新建(new): 新创建一个线程对象；
    
  2) 可运行(runnable): 线程对象创建后，当调用线程对象的start()方法，该线程处于就绪状态，等待被线程调度选中，
        获取CPU的使用权；
  3) 运行(running): 可运行状态(runnable)的线程获得了CPU时间片（timeslice），执行程序代码。注：就绪状态是进入
        到运行状态的唯一入口，也就是说，线程想要进入运行状态执行，首先就必须处于就绪状态中；
  4) 阻塞(block): 处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到
        其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态；
        
    阻塞的情况分三种：
        1) 等待阻塞：运行状态中的线程执行wait()方法，JVM会把该线程放入等待队列（waiting queue）中，使本线程进入到
            等待阻塞状态；
        2) 同步阻塞: 线程在获取synchronized同步锁失败(因为锁被其他线程占用)，则JVM会把该线程放入锁池（lock pool）中，
            线程会进入同步阻塞状态；
        3) 其他阻塞: 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入阻塞状态。当sleep()状态超时、join()
            等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
           
  5) 死亡(dead): 线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。

#### Java 用到的线程调度算法
        计算机通常只有一个CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU的使用权才能执行命令。
    所谓多线程的并发执行，其实是指从宏观上看，各个线程轮流获得CPU的使用权，分别执行各自的任务。在运行池中，
    会有多个处于就绪状态的线程在等待CPU，JAVA虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制
    为多个线程分配CPU的使用权。
    
        有两种调度模型：分时调度模型和抢占式调度模型
        
        分时调度模型是指让所有线程轮流获得CPU的使用权，并且平均分配每个线程占用的CPU的时间片；
        
        JAVA虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行的线程池
    优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU。
    
#### 如何停止一个正在运行的线程
  在JAVA中有以下3种方法可以终止正在运行的线程：
    1、使用退出标志，使线程正常退出，也就是当run()方法完成后线程终止；
    2、使用stop()方法强行终止，但不推荐这个方法，因为stop和suspend及resume一样都是过期作废方法；
    3、使用interrupt方法中断线程；
    
#### JAVA如何实现多线程之间的通讯和合作
  可以通过中断和共享变量的方式实现线程间的通讯和协作
    
        比如说最经典的生产者-消费者模型：当队列满时，生产者需要等待队列有空间才能继续往里放入商品，
    而在等待期间内，生产者必须释放对临界资源(即队列)的占用权。因为生产者如果不释放对临界资源的占用权，
    那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此，一般
    情况下，当队列满时，会让生产者交出对临界资源的占用权，并且进入挂起状态。然后等待消费者消费了商品，
    然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待消费者通知它队列里有
    商品了。这种互相通信的过程就是线程间的合作。
    
  JAVA中线程通信协作的最常见的两种方式
    1) synchronized加锁的线程的Object类的wait()/notify()/notifyAll()
    2) ReentrantLock类加锁的线程的Condition类的await()/signal()/signalAll()
    
  线程间直接的数据交换
    3) 通过管道进行线程间通信：a:字节流；b:字符流
    
    
#### 什么叫线程安全？servlet是线程安全的吗？
  线程安全是编程中的术语，指某个方法再多线程环境中被调用时，能够正确的处理多个线程之间的共享变量，
使程序能够正确完成。

  Servlet不是线程安全的，servlet是单实例多线程的，当多个线程同时访问一个方法，是不能保证共享变量的线程安全的。
  
  Struts2 的 action 是多实例多线程的，是线程安全的，每个请求过来都会 new 一个新的 action 分配给这个请求，请求完成后销毁。
  
  SpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程。
  
  Struts2 好处是不用考虑线程安全问题；Servlet 和 SpringMVC 需要考虑线程安全问题，但是性能可以提升不用处理太多的 gc，
可以使用 ThreadLocal 来处理多线程的问题。

## 并发理论
### JAVA内存模型
#### JAVA中垃圾回收有什么目的？什么时候进行垃圾回收

  垃圾回收是在内存中存在没有引用的对象或者超过作用域的对象时进行的。
  
  垃圾回收的目的是识别并丢弃应用不再使用的对象来释放和重用资源。    
  
### 重排序与数据依赖性
#### 为什么代码会重排序
  在执行程序时，为了提供性能，处理器和编译器常常会对指令重排序，但不能随意重排序，它需要满足两个条件：
    1) 在单线线程环境下不能改变程序运行的结果；
    2) 存在数据依赖关系的不允许重排序；
    
  需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。
  
## 并发关键字
### synchronized
#### synchronized 的作用
    
        在JAVA中，synchronized关键字是用来控制线程同步的，就是在多线程的环境下，控制synchronized代码段不被多个线程同时执行。
    synchronized可以修饰类、方法、变量。
    
        另外，在JAVA早起版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock
    来实现的，JAVA的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统
    实现线程之间的切换时需要从用户态切换到内核态，这个状态之间的转换需要相对较长的时间，时间成本相对较高，这也是为什么早期
    的synchronized效率低的原因
    
### volatile
#### volatile 关键字的作用
        
        对于可见性，JAVA提供了volatile关键字来保证可见性和禁止指令重排。volatile提供happens-before的保证，确保一个线程的修改
    能对其他线程是可见的。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主内存，当有其他线程需要读取时，它会去
    内存读取新值。
        
        从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性。
        
        volatile常用语多线程环境下的单词操作。
        
#### JAVA中能创建volatile数组吗

        能，JAVA中可以创建volatile类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到
    volatile的保护，但如果多个线程同时改变数组的元素，volatile标示符就不能起到之前的保护作用了。 

### AQS(AbstractQueuedSynchronizer)原理

  AQS的核心思想是，如果被请求的共享资源空闲，则当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。
如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将
暂时获取不到锁的线程加入到队列中。

      CLH 队列是一个虚拟的双向队列（虚拟的双向队列即不存在的队列实例，仅存在节点之间的关联关系）。AQS是将每条请求共享资源
    的线程封装成一个CLH锁队列的一个节点（Node）来实现锁的分配。
    
 ### AQS 底层使用了模板方法模式
   
   同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：
     1) 使用者继承AbstractQueuedSynchronizer并重写指定方法。（对共享资源state的获取和释放）
     2) 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。
     
     

